<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当我们刚开始我们的码农生涯时，我们该做些什么]]></title>
    <url>%2F2018%2F02%2F10%2F%E5%BD%93%E6%88%91%E4%BB%AC%E5%88%9A%E5%BC%80%E5%A7%8B%E6%88%91%E4%BB%AC%E7%9A%84%E7%A0%81%E5%86%9C%E7%94%9F%E6%B6%AF%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[最近公司新来了一个妹子，老大让我带。妹子大大的眼睛，一眨一眨的，灰常可爱。从她身上我仿佛看到了两年前的自己，从面对业务的各种懵逼，到完不成任务时主动加班，蓦然有一种恍如隔日的感觉。所以想和大家聊聊当我们刚开始我们的码农生涯时，我们该做些什么？ 写在前面先聊一下带妹子这两周的趣事，感觉很有意思。记得当老大说让我带妹子的时候，我的心情是这样的 然后事情并非总朝着预料中的方向发展，妹子说的对我说的最多的一句话居然是 大哥，我eclipse炸了大哥，我eclipse又炸了大哥，我eclipse又又炸了 还好妹子没叫我大叔，我想对妹子说的是，虽然我长的有点着急，但头发少代表着睿智，真不代表年龄 妹子奉行着初入江湖无所畏惧的精神，刚来一周就光荣的提交了一个bug上线了，加班填坑的事就不说了，吓得我对妹子提交的代码必须要review，然后就有了下面的对话 我：分号为什么不换行？妹子：别人都没换，，，我：你怎么知道这个地方能取到值？妹子：我猜的，，，我：记笔记咱能不能记到电脑上？妹子：，，，我：同样的代码你为啥要写四遍，不能抽象出来吗？妹子：，，，我：你这1，2，3是什么意思，这是魔术数字知不知道？妹子：，，， 最后，我想对妹子说，不是哥哥针对你，是因为你桌子上放的糖，总是不让我吃。额不，是因为你要打好基础，我都是为了你好，嗯，是这样的。 主动出击我说的可不是主动出击追妹子，而是当你以菜鸟的身份初入职场时。要主动出击了解公司的各种规章制度和项目流程。对于整个项目的开发流程，各种开发环境，版本控制管理，都要有所了解。 不能糊里糊涂什么都等着别人安排，不然等到代码提交错分支或者连错数据库等问题时徒增尴尬。殊不知，或许这些信息项目的文档里都有，只是你没去看而已。 取人之长,补己之短无知不可怕，可怕的是不自知。初入职场，遇到问题，虚心的像别人请教是快速成长的不二法门。或者你纠结了几天的问题，老司机一句话就点醒了你。 但问问题要讲究方法，最起码是自己尝试过解决之后再去问。例如，项目启动不了，你要告诉给你解决问题的人：最近有没有改过什么东西；自己尝试过哪些解决办法；以及自己判断是什么原因造成的等。而不是简单一句：我项目启动不了了，帮我看看呗。 善于学习而不迷信。多看看老司机写的代码，想一想如果自己的话该如何写，取其精华，去其糟粕。不加分辨一味地去模仿是不可取的。要养成自己独立思考的习惯。 承担责任不要因为自己是菜鸟而怕担责任，也不要因为给你分了简单的任务而暗自窃喜。回想自己的两年多码农生涯，让我成长最多的不是分分钟就写完的简单业务代码，也不是上来就可以复制粘贴的增删改查，而是折磨了我无数次的变态需求，还有那些加班加点的奋战。 如果分任务的时候，每次你拿到的都是最轻松的，最简单的，恰恰也说明了你是团队中最无能的。如果你能主动承担相对麻烦的，有难度的任务，也许你会为此付出更多时间，会踩更多的坑，但这也恰恰是你成才的机会。 持续学习曾经，我认为“码农”二字只是对程序员的一句调侃而已，现如今却发现是不能再真的事实。如今的程序员犹如过江之鲫，何止百万。如若不能脱颖而出，必然要成为所谓三十五岁被辞退的一员。而持续学习则是不被淘汰的必经之路。 如果你每天晚上有两个小时的空闲时间，以前全部都在打王者农药，现在你可以尝试分出来一个小时去学习。 如果你把一个小时交给了自由和享受，也不要忘了把另外一个小时交给梦想和责任。 写在最后 听说你们公司新来了一个妹子让你带啊是啊妹子哪的人呢额，，，有男朋友吗？额，，，有啥爱好？额，，， 这些你不知道，你说你知道啥我知道妹子昨天提交的代码第168行多了一个分号 这么说你是有对象喽那个，new的算吗]]></content>
  </entry>
  <entry>
    <title><![CDATA[2017总结：沉淀、反思、前行]]></title>
    <url>%2F2018%2F01%2F01%2F2017%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B2%89%E6%B7%80%E3%80%81%E5%8F%8D%E6%80%9D%E3%80%81%E5%89%8D%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[2017如果非要概括一下的话，我想应该是沉淀，反思，前行 关于技术犹记得2016时的自己，初入java江湖，年少轻狂，自认为自己已经登堂入室，编程江湖任我驰骋。现在想想实在可笑，自己当时不过是一个连ssh api都没完全搞懂的不入门码农。 2017的自己不在盲目追求新兴的技术，更注重内功。尝试着去阅读一些jdk源码，spring源码。虽然很多仍旧看不懂。但时不时会有一种豁然开朗的感觉。对于项目中用到的技术，在使用的同时，常常去想一下为什么，尽量做到知其然并知其所以然。 当然这一年也学习了不少新知识，虽然工作中未必用到，但仍会去学习。学习号称颠覆Java应用开发的Spring Boot，新的持久化方式spring data jpa, 学习现在流行mvvm前端框架vue,并且对于日常工作中的重复劳动，做了个小工具。 对于学习中遇到的问题，我一直有记笔记的习惯。17年也尝试去写博客，真到写的时候才发现，写博客和记笔记完全是两个不同概念。写博客更多的是梳理总结自己知识，还要保证其准确性，以免给别人引起误导。于是乎，17年零零散散的也没写几篇。新的一年要坚持写博客，写有质量的博客。 关于读书我算不得一个爱读书的人，但现在却越来越喜欢读书的感觉。因为看书能使我静心，这种感觉真的很好。但我又是一个有松鼠症的人，这一年也买了一些技术书，但很多并未认真看，除了放在书桌上证明自己是一个所谓的“爱学习”的人之外，并没有任何作用。 不过这一年非技术书籍到是读了不少。看阮一峰老师的《前方的路》和《未来世界的幸存者》，被阮老师渊博的知识和对知识的求知欲深深折服；看吴军博士的《浪潮之巅》，感受it行业的风云变幻，跌宕起伏。看安意如的《人生若只如初见》和《陌上花开》，让我这个诗词白痴对中国的诗词文化也产生了浓厚的兴趣；看东野圭吾的《解忧杂货店》，让我明白人生征途的地图一直在自己手中。书中未必有黄金屋，也未必有颜如玉，但读书可以提高一个人独立思考的能力，看事情的格局。法国思想家帕斯卡尔有一句名言: 人是一根会思考的芦苇 懂得思考的人生才更有趣。 关于坚持有时每天坚持一件事真的是很难的事，但一旦养成习惯，一切似乎又会变得很简单。古人云： 苟有恒,何必三更眠五更起最无益,莫过一日暴十日寒 现在养成了每天晚上看书的习惯，不看一会总感觉少点啥。就如同每天晚上一点睡觉的坏习惯一样，睡的早反而睡不着。 关于努力有时认为自己已经很努力只是别人看不到而已。但仔细想想，都是自己再麻痹自己而已。想想自己，上班敲代码的同时总是穿插着聊天，听歌等事情。没有专注度，何谈效率。公司架构师经常会在群里面分享一些it知识，而且很多都是在休息日，想想自己休息日在家做什么。才发现只是自己认为自己很努力，自己感动自己而已。新的一年，要更专注，注重效率，注重结果，而不是所谓的努力程度。 关于岁月最近几天大家发都在晒自己的18岁，我看了看自己18岁的照片，又看了看现在的自己，蓦然有一种恍如隔世的感觉。曾经的青葱少年，现在整个人完全像气球一样膨胀起来，似乎已经成为了中年胖大叔。岁月不是把杀猪刀，岁月是把猪饲料。 展望2018新的一年要坚持自己的一些好习惯，改掉坏习惯。每天晚上至少读书一个小时，十二点之前睡觉，每周至少去健身房两次。或许再也回不去18岁时候的追风少年，但人生的征途其实才刚刚启程，愿我，不忘初心，愿我，勇敢前行。 在网上看到这样一句话，很喜欢 后来许多人问我一个人夜晚踟蹰路上的心情，我想起的却不是孤单和路长，而是波澜壮阔的海和天空中闪耀的星光。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring JDBC（二）SimpleJdbcInsert]]></title>
    <url>%2F2017%2F12%2F14%2FSpring%20JDBC%EF%BC%88%E4%BA%8C%EF%BC%89SimpleJdbcInsert%2F</url>
    <content type="text"><![CDATA[上一篇写了关于jdbcTemplate的一些基本使用，这一篇来聊聊SimpleJdbcInsert SimpleJdbcInsert是springjdbc提供的一个简化插入操作的类，下面来看一下常用的api 创建SimpleJdbcInsert实例创建一个用户表 123456CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `user_name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 创建实例 123456789101112private SimpleJdbcInsert simpleJdbcInsert;private DriverManagerDataSource dataSource;@Beforepublic void init() &#123; dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/blogsrc?useUnicode=true&amp;characterEncoding=UTF-8"); dataSource.setUsername("root"); dataSource.setPassword("zhao"); simpleJdbcInsert = new SimpleJdbcInsert(dataSource);&#125; 新增通过withTableName绑定需要操作的数据库表，然后指定新增的参数 12345678910/** * simpleJdbcInsert新增 */ @Test public void insertTest() &#123; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3); parameters.put("user_name", "小明"); parameters.put("password", "123456"); simpleJdbcInsert.withTableName("user").execute(parameters); &#125; 返回主键通过usingGeneratedKeyColumns指定主键，executeAndReturnKey执行并返回主键，返回的主键为Number类型，如有需要，自行转换 12345678910111213/** * simpleJdbcInsert新增，并返回主键 */@Testpublic void insertAndReturnPrimaryKeyTest() &#123; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3); parameters.put("user_name", "小明"); parameters.put("password", "123456"); Number primaryKey = simpleJdbcInsert.withTableName("user") .usingGeneratedKeyColumns("id")// 指定主键列名 .executeAndReturnKey(parameters); System.out.println("主键为：" + primaryKey);&#125; 限制插入的列usingColumns方法可以限制插入的列 1234567891011121314/** * simpleJdbcInsert新增，返回主键，并限制插入的列 */@Testpublic void usingColumnsTest() &#123; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3); parameters.put("user_name", "小明"); parameters.put("password", "123456"); Number primaryKey = simpleJdbcInsert.withTableName("user") .usingColumns("user_name")// 限制输入的列，因为限制只新增用户名，所以password的值不会进数据库 .usingGeneratedKeyColumns("id")// 指定主键列名 .executeAndReturnKey(parameters); System.out.println("主键为：" + primaryKey);&#125; SqlParameterSourceSqlParameterSource接口对sql参数进行了封装，两个常用的实现BeanPropertySqlParameterSource和MapSqlParameterSource，BeanPropertySqlParameterSource可以通过javabean构造，MapSqlParameterSource则可以用map构造 12345678910111213141516171819202122232425@Test public void sqlParameterSourceTest() &#123; User user = new User(); user.setUserName("小明"); user.setPassword("123456"); // BeanPropertySqlParameterSource SqlParameterSource sqlParm = new BeanPropertySqlParameterSource(user); simpleJdbcInsert.withTableName("user").execute(sqlParm); // MapSqlParameterSource simpleJdbcInsert = new SimpleJdbcInsert(dataSource); Map&lt;String, Object&gt; mapParameters = new HashMap&lt;String, Object&gt;(); mapParameters.put("user_name", "小明"); mapParameters.put("password", "123456"); SqlParameterSource sqlParmMap = new MapSqlParameterSource(mapParameters); simpleJdbcInsert.withTableName("user").execute(sqlParmMap); simpleJdbcInsert = new SimpleJdbcInsert(dataSource); // 也可以通过MapSqlParameterSource addValue 添加参数 SqlParameterSource sqlParmMapAdd = new MapSqlParameterSource() // addValues(map) 一次添加多个参数 .addValue("user_name", "小明")// 单个添加 .addValue("password", "123456"); simpleJdbcInsert.withTableName("user").execute(sqlParmMapAdd); &#125; 需要注意jdbcTemplate是线程安全的，所以可以一直使用同一个实例，但simpleJdbcInsert不是线程安全的，每次使用都要获取一个新的simpleJdbcInsert实例 完整的源码 https://github.com/zhaoguhong/blogsrc]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring JDBC（一）jdbcTemplate]]></title>
    <url>%2F2017%2F12%2F07%2FSpring%20JDBC%EF%BC%88%E4%B8%80%EF%BC%89jdbcTemplate%2F</url>
    <content type="text"><![CDATA[前言最近工作中经常使用Spring JDBC操作数据库，也断断续续的看了一些源码，便有了写一些总结的想法，希望在能帮助别人的同时，也加深一下自己对Spring JDBC的理解。 Spring JDBC 简介Spring JDBC 是spring 官方提供的一个持久层框架，对jdbc进行了抽象和封装，消除了重复冗余的jdbc重复性的代码，使操作数据库变的更简单。 但Spring JDBC本身并不是一个orm框架，与hibernate相比，它需要自己操作sql,手动映射字段关系，在保持灵活性的同时，势必造成了开发效率的降低。如果需要使用完整的orm框架操作数据库，可以使用hibernate或者spring Data Jpa。 Spring JDBC不同版本的api会稍有变动，但总体的变化不大，以下测试代码均使用4.3.11.RELEASE。 模板类Spring JDBC 提供了模板类对数据库简化对数据库的操作，其中JdbcTemplate是最常用的，如果需要使用命名参数可以使用NamedParameterJdbcTemplate，SimpleJdbcTemplate在3.1版本已经标记过时，在我使用的4.3版本中，已经被删除。 JdbcTemplate 入门示例JdbcTemplate使用很简单，注入一个数据源就可以使用了 123456789101112131415161718192021public class A001SpringJdbcJdbcTemplateTest &#123; private JdbcTemplate jdbcTemplate; @Before public void init() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/blogsrc?useUnicode=true&amp;characterEncoding=UTF-8"); dataSource.setUsername("root"); dataSource.setPassword("zhao"); jdbcTemplate = new JdbcTemplate(dataSource); &#125; @Test public void queryTest() &#123; String sql = "select * from user"; List&lt;Map&lt;String, Object&gt;&gt; users = jdbcTemplate.queryForList(sql); System.out.println(users); &#125;&#125; 对于参数赋值，可以采用占位符的方式 123456@Testpublic void queryByParameterTest() &#123; String sql = "select * from user where id =?"; List&lt;Map&lt;String, Object&gt;&gt; users = jdbcTemplate.queryForList(sql, 1L); List&lt;Map&lt;String, Object&gt;&gt; users1 = jdbcTemplate.queryForList(sql, new Object[] &#123;1L&#125;);&#125; mapper映射Spring JDBC 通过mapper接口把resultSet对象中的数据映射为java对象，例如上述例子中返回 List&lt;Map&lt;String, Object&gt;&gt;，其实使用的是ColumnMapRowMapper的mapper实现。我们自己可以通过实现RowMapper接口的方式自定义从resultSet到java对象的映射关系。 先创建一个table 123456CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) NOT NULL, `user_name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; User实体类 12345public class User implements Serializable &#123; private Long id; private String userName; private String password;&#125; 自定义mapper映射 12345678910111213@Testpublic void simpleMapperTest() &#123; String sql = "select * from user"; List&lt;User&gt; users = jdbcTemplate.query(sql, new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getObject("id") == null ? null : rs.getLong("id")); user.setUserName(rs.getString("user_name")); user.setPassword(rs.getString("password")); return user; &#125; &#125;);&#125; 调用存储过程对于数据库数据的更新操作，可以直接调用update接口，如果是存储过程，可以通过execute完成调用。 新建一个简单的存储过程test 12345DROP PROCEDURE IF EXISTS test;CREATE PROCEDURE test (IN userId BIGINT ( 20 ),OUT userName VARCHAR ( 200 ) ) BEGINSET userName = ( SELECT user_name FROM USER WHERE id = userId );END; 1234567891011121314151617181920@Testpublic void proTest() &#123; String sql = "insert into user (user_name,password) VALUES (?, ?)"; jdbcTemplate.update(sql, "赵孤鸿", "123456"); // 插入数据 String userName = jdbcTemplate.execute(new CallableStatementCreator() &#123; public CallableStatement createCallableStatement(Connection con) throws SQLException &#123; String proc = "&#123;call test(?,?)&#125;"; CallableStatement cs = con.prepareCall(proc); cs.setLong(1, 1L);// 设置输入参数的值 索引从1开始 cs.registerOutParameter(2, Types.VARCHAR);// 设置输出参数的类型 return cs; &#125; &#125;, new CallableStatementCallback&lt;String&gt;() &#123; public String doInCallableStatement(CallableStatement cs) throws SQLException, DataAccessException &#123; cs.execute(); return cs.getString(2);// 返回输出参数 &#125; &#125;); System.out.println(userName);&#125; NamedParameterJdbcTemplateNamedParameterJdbcTemplate的使用基本上和JdbcTemplate类似，只不过参数的赋值方式由占位符变成了命名参数，命名参数优势在于，如果一个相同的参数出现了多次，只需要进行一次赋值即可。创建NamedParameterJdbcTemplate对象的两种方式 1234// 方式1namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);// 方式2namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource); 12345678@Testpublic void namedParameterJdbcTemplateTest() &#123; String sql = "select * from user where id =:id"; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(); parameters.put("id", 1L); List&lt;Map&lt;String, Object&gt;&gt; users = namedParameterJdbcTemplate.queryForList(sql, parameters); System.out.println(users);&#125; batchUpdate对于大数据量的数据更新，可以采用batchUpdate接口 12345678910111213141516171819202122232425@Testpublic void batchUpdateTest() &#123; String sql = "insert into user (user_name,password) VALUES (?, ?)"; List&lt;User&gt; users = Lists.newArrayList(); for (int i = 0; i &lt;= 10; i++) &#123; User user = new User(); user.setUserName("xiaoming"); user.setPassword("123456"); users.add(user); &#125; jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() &#123; @Override public void setValues(PreparedStatement ps, int i) throws SQLException &#123; User user = users.get(i); int count = 0; ps.setString(++count, user.getUserName());// 索引从1开始 ps.setString(++count, user.getPassword()); &#125; @Override public int getBatchSize() &#123; return users.size(); &#125; &#125;);&#125; 与spring整合只需要注入数据源即可 1234567891011 &lt;!-- 省略dataSource相关配置 --&gt; &lt;!-- 配置 Spirng 的 JdbcTemplate --&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置 NamedParameterJdbcTemplate --&gt;&lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 如果是springboot项目，直接使用即可 12@Autowiredprivate JdbcTemplate jdbcTemplate; 注意事项关于queryForObject,如果没有查询到，或者查询到多个，都会抛异常，看一下源码 1234567891011// 未查询到，或者查询到多个，都会抛异常public static &lt;T&gt; T requiredSingleResult(Collection&lt;T&gt; results) throws IncorrectResultSizeDataAccessException &#123; int size = (results != null ? results.size() : 0); if (size == 0) &#123; throw new EmptyResultDataAccessException(1); &#125; if (results.size() &gt; 1) &#123; throw new IncorrectResultSizeDataAccessException(1, size); &#125; return results.iterator().next();&#125; queryForMap最终走的也是queryForObject方法，因此，使用时也要注意 在自定义mapper获取ResultSet的值时，获取基本类型数据会有默认值，解决办法如下 12Long id = rs.getLong(&quot;id&quot;);//如果id为null,会默认0Long id1 = rs.getObject(&quot;id&quot;) == null ? null : rs.getLong(&quot;id&quot;);//先判断是否为null 完整的 源码 https://github.com/zhaoguhong/blogsrc]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习站点]]></title>
    <url>%2F2017%2F10%2F19%2F%E5%AD%A6%E4%B9%A0%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[个人博客 阮一峰的网络日志 廖雪峰的官方网站 月光博客 左潇龙的博客 chenssy的博客 技术小黑屋 嘟嘟独立博客 spring boot 系列 纯洁的微笑 spring boot 系列 团队博客 阿里中间件 美团 工具 程序员在线工具 github GitHub 漫游指南 技术社区 博客园 都是干货，最爱 csdn 广告多，广告多，广告多 开源中国 MDN 导航 程序员导航 程序员学习资料 技术文档 Spring MVC 4.2.4.RELEASE 中文文档 ECMAScript 6 入门 MDN JS 关于我 个人博客 github 博客园]]></content>
  </entry>
  <entry>
    <title><![CDATA[java踩坑记]]></title>
    <url>%2F2017%2F09%2F27%2Fjava%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.String 相等稍微有点经验的程序员都会用equals比较而不是用 ==，但用equals就真的安全了吗，看下面的代码 1user.getName().equals("xiaoming"); 有经验的老司机很快就能看到问题，如果user.getName()为null,就会抛出空指针异常，因此下面的写法更为稳妥 1"xiaoming".equals(user.getName()); 当然这种写法并不是万能的，如果比对的两边都是未知变量,如下 1user.getName().equals(user1.getName());//user.getName() 和 user1.getName()都有可能为null 因此更为稳妥的方法可以采用jdk Objects类中的equals方法，左右两边都可以避免空指针异常 1Objects.equals(user.getName(), user1.getName()); 需要注意的是Objects类在jdk1.7才支持，如果是jdk1.6,可以采用guava中的Objects类代替 2.Integer 比较123456Integer a = 127;Integer b = 127;Integer c = 128;Integer d = 128;System.out.println(a == b);// 结果为：trueSystem.out.println(c == d);// 结果为：false 令人惊讶的是结果并不是预料中的全是true,而是一个为true,一个为false至于原因还需要从源码中探究 首先通过源码来看一下，当通过 = 对Integer赋值时，实际调用了Integer.valueOf()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;``` 可以看到当 i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high 时，是从一个缓存类中取，其它情况会new一个对象。IntegerCache.low默认为-128，high默认为127（可调整）。这样a=b就很好解释了，因为==比较的是内存地址，a，b都是从这个缓存类中取的同一个对象，所以返回结果为true。b,c则都是new的新对象，内存地址自然不同，所以返回false既然看到了这个缓存类，就有必要一睹它的庐山真面目了```javaprivate static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125;``` IntegerCache 是Integer类中一个静态内部类，high值可通过JVM 的启动参数设置### 3.Arrays.asList(array)```javaString [] array= &#123;"a","b","c"&#125;;// 返回的List实例为：java.util.Arrays.ArrayListList&lt;String&gt; list = Arrays.asList(array);list.remove(0); Arrays.asList是一种很常见的创建List的方式，但该方法返回的List实例不是平时常用的List实例，而是Arrays的一个静态内部类，该类继承自AbstractList类，并为提供List的完整的实现，例如remove方法就未实现，当然，如果只是用做遍历，则完全是没问题的 类似的情况还有不少，使用时要注意，例如： ArrayList的subList方法，返回的是ArrayList中的一个内部类12. HashMap的values方法，返回的是HashMap中的一个内部类：```java.util.HashMap.Values 4.list.toArray12List&lt;String&gt; list = new ArrayList&lt;String&gt;();String[] array=(String[]) list.toArray(); 上面的写法乍一看似乎没有什么问题，但list.toArray()返回的是一个object数组，强转会抛异常。其实是可以指定返回数组的类型的，如下 1String[] array=list.toArray(new String[list.size()]); 5.foreach remove1234567List&lt;String&gt; list =new ArrayList&lt;String&gt;();list.add("java");list.add("c");list.add("js");for(String str:list)&#123; list.remove(0);&#125; 在遍历时删除元素也是比较常用的操作，但foreach时删除元素有可能抛异常，这种不好控制的写法还是不用为好，可以用迭代器去代替 1234for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();) &#123; String str = iterator.next(); iterator.remove();&#125; 6. String getBytes12String str="韦德";byte[] bytes = str.getBytes(); String的getBytes()方法用的是当前项目的默认编码，如果不指定编码，在不同的运行环境很容易被坑，所以还是根据自己的需要指定对应的编码比较靠谱 12String str="韦德";byte[] bytes = str.getBytes("utf-8");]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外面的雨还在下]]></title>
    <url>%2F2017%2F09%2F25%2F%E5%A4%96%E9%9D%A2%E7%9A%84%E9%9B%A8%E8%BF%98%E5%9C%A8%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;外面的雨还在淅淅沥沥不停的下，下雨似乎也是上海的特色之一，上海的雨似乎也不能减少这座城市的喧嚣，大街依旧车水毛龙，热闹非凡。听老妈说家里也在下雨，老家的雨给庄稼的收割带来了不小的阻挠，想来这个时间家里的玉米也该收了。 一个人&emsp;&emsp;已经到了吃晚饭的时候了，但不想做饭，也不想出去吃。一个人的生活就是这么任性。不会因为到了吃饭的时间就是吃饭，也不会到了睡觉的时间就去睡觉，随心所欲。 工作&emsp;&emsp;其实说实话，最近工作上的压力其实越来越小，毕竟来公司也已经一年多了。各方面也逐渐步入正轨。但工作外的烦心事似乎一直都没断过。但人生就是如此，我不会因此去抱怨。但有时候却又不由莫名的心慌，不知道为什么越是稳定的生活越是让我感觉到恐慌。总感觉自己进入了一种温水煮青蛙的状态。恐慌带来的是心烦意乱，晚上总是睡的很晚，身体很诚实的告诉我该睡觉了，但大脑却格外清晰，躺了好久也睡不着了。有时我在想，什么时间自己有一个技能，可以短暂性的清空大脑。让自己可以每天睡前大脑完全放空，那该多好。 心累&emsp;&emsp;昨天晚上回到住处门口时，一个漂亮的小姐姐在门口打电话。隐约听见她对着电话说：“也没什么，就是感觉心累”。回到屋子里我就想：为什么会感觉到心累。倘若一无所求，面对生活只想顺其自然，随波逐流，自然不会心累；亦或者人生一帆风顺，爱情事业双丰收，早已是人生赢家，这样的人自然也不会心累；或许只有像我们这种人，心中有着梦想，即使困难重重，仍然逆流而上，但理想和现实仍旧存在较大差距，才会感觉心累吧。 一直如此&emsp;&emsp;电影这个杀手不太冷里面有这样一段对白，玛蒂达：人生总是这么苦么，还是只有童年如此？里昂说：一直如此。是啊，一直如此，生活一直充斥着各种各样发烦恼，困难，但人生不也正是因为这些困难才变得更加丰富多彩吗？ 安和桥&emsp;&emsp;最近疯狂的迷上的宋胖子的安河桥，单曲循环了一遍又一遍。其实很早就听过这首民谣，但当时更偏爱董小姐，而今却独爱安和桥。 我知道 那些夏天就像你一样回不来 我已不会再对谁 满怀期待 我想，我依旧对明天满怀期待，不论爱情，还是其它 外面的雨似乎下的更大了]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法之冒泡排序]]></title>
    <url>%2F2017%2F09%2F03%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序是一种非常常见的排序算法。如同水中的一排泡泡，先冒出最大的一个泡泡。再冒出剩余泡泡中的最大泡泡，依次类推，它的排序规则如下： 从第一个元素开始，比较相邻的两个元素，如果后面的小于前面的，交换两个的位置，一直比较到最后一个 循环1中的操作，但已经确定的最大的元素不再参与比较 直到不确定大小顺序的元素剩余两个，然后对这两个进行比较，然后结束循环 排序图示（图片来源网络） java实现用java实现一个简单的冒泡排序。为了便于理解，在寻找到第一个最大元素完成后，称之为第一趟，依次类推，可以发现一共需要n-1趟 1234567891011121314public void bubbleSort() &#123; int[] array = &#123;6, 2, 5, 3&#125;; for (int i = 0; i &lt; array.length - 1; i++) &#123;// 需要排序的趟数 for (int j = 0; j &lt; array.length - i - 1; j++) &#123;// 每一趟需要比较的次数 if (array[j + 1] &lt; array[j]) &#123; int variable = array[j + 1]; array[j + 1] = array[j]; array[j] = variable; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的结果：" + Arrays.toString(array)); &#125; System.out.println("最终的排序结果：" + Arrays.toString(array));&#125; console 1234第1趟排序后的结果：[2, 5, 3, 6]第2趟排序后的结果：[2, 3, 5, 6]第3趟排序后的结果：[2, 3, 5, 6]最终的排序结果：[2, 3, 5, 6] 排序过程分析第一趟排序 排序前：[6, 2, 5, 3] 排序后：[2, 5, 3, 6] 6与2比较，然后互换位置，然后与5比较，互换位置，最后与3比较，互换位置,此时6在最后的位置，确定最大值6，一共比较3次 第二趟排序 排序前：[2, 5, 3, 6] 排序后：[2, 3, 5, 6] 2与3比较，位置不变，然后5与3比较，然后互换位置，因为6的位置已经确定，所以5与6不再比较，一共比较2次 第三趟排序 排序前：[2, 3, 5, 6] 排序后：[2, 3, 5, 6] 2与3比较，位置不变，5,6的位置已经确定，所以不再比较，一共比较1次 由上面的分析可以看出，一共进行了1+2+…+n-1次比较。也就是n(n-1)/2次,即(N^2 - n)/2次,去除对结果影响不大的N^2 - n中的-n,以及系数0.5，得出时间复杂度为 O(N^2) (注：此处的时间复杂度自己尚未完全理解，希望明白的朋友可以给予解答) 优化上述的排序还存在优化的空间，如果本来就是一列从小到大的数，按上述操作，很容易造成资源浪费。最理想的情况下，对于一列从小到大的数，进行n次比较，即可得出结果。如果某一趟排序中，没有出现互换操作，即表示已经得到了正确的结果，此时可以结束排序，示例如下： 123456789101112131415161718public void bubbleSort() &#123; int[] array = &#123;6, 2, 5, 3&#125;; for (int i = 0; i &lt; array.length - 1; i++) &#123;// 需要排序的趟数 boolean flag = false;// 默认不存在位置交换 for (int j = 0; j &lt; array.length - i - 1; j++) &#123;// 每一趟需要比较的次数 if (array[j + 1] &lt; array[j]) &#123; flag = true;// 存在位置交换，修改flag为true int variable = array[j + 1]; array[j + 1] = array[j]; array[j] = variable; &#125; &#125; if (!flag) &#123; break;// 不存在位置交换 跳出循环 &#125; &#125; System.out.println("最终的排序结果：" + Arrays.toString(array));&#125;]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中List Array相互转换]]></title>
    <url>%2F2017%2F08%2F14%2Fjava%E4%B8%ADList%20Array%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[List to ArrayList 提供了toArray的接口，所以可以直接调用,转为object型数组 12List&lt;String&gt; list = new ArrayList&lt;String&gt;();Object[] array=list.toArray(); 当然也可以指定类型 1String[] array=list.toArray(new String[list.size()]); Array to List最简单的方法似乎是这样 12String[] array = &#123;"java", "c"&#125;;List&lt;String&gt; list = Arrays.asList(array); 但该方法存在一定的弊端，返回的list是Arrays里面的一个静态内部类，该类并未实现add,remove方法，因此在使用时存在局限性 12345public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;// 注意该ArrayList并非java.util.ArrayList// java.util.Arrays.ArrayList.ArrayList&lt;T&gt;(T[]) return new ArrayList&lt;&gt;(a);&#125; 运用ArrayList的构造方法是目前来说最完美的作法,代码简介，效率高 12345678910List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array));//ArrayList构造方法源码public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 运用Collections的addAll方法也也是不错的解决办法 12List&lt;String&gt; list = new ArrayList&lt;String&gt;(array.length);Collections.addAll(list, array); Array or List 分隔其实自己实现一个分隔list或者数组的方法也并不复杂，但强大的第三方库自然提供的有此类似的功能 1234// org.apache.commons.lang3.StringUtils.join(Iterable&lt;?&gt;, String)StringUtils.join(list, ",")// org.apache.commons.lang3.StringUtils.join(Object[], String)StringUtils.join(array, ",")]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 迭代器浅析]]></title>
    <url>%2F2017%2F08%2F01%2Fjava%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介迭代器是遍历容器的一种常用方法，它屏蔽了容器的实现细节，无需暴露数据结构内部，就可以对容器进行遍历，迭代器本身也是一种设计模式，迭代是一种特殊的遍历方式 Iterator在java中，迭代器接口Iterator定义了三种方法 1234567891011public interface Iterator&lt;E&gt; &#123; // 是否还有元素可以迭代，如果有 返回true 没有返回false boolean hasNext(); // 返回迭代的下一个元素 E next(); // 从迭代器指向的 collection 中移除迭代器返回的最后一个元素 void remove();&#125; remove方法是移除迭代器返回的最后一个元素，因此如果没有调用过next方法，直接调用remove方法是错误的做法，并且每执行一次next方法，只能调用一次remove方法 IterableIterable只有一个iterator方法，该方法会返回一个迭代器,一般情况下使用迭代器的类都会实现Iterable接口而非直接实现Iterator接口 1234public interface Iterable&lt;T&gt; &#123; // 返回一个在一组 T 类型的元素上进行迭代的迭代器。 Iterator&lt;T&gt; iterator();&#125; foreach 就是对迭代器的另外一种使用方式，只要是实现Iterable接口的类，就可以用foreach对自身进行遍历 map 迭代map接口并未继承Iterable接口，因此本身并不能直接使用迭代器，不过可以转化为collection然后进行迭代，例如： 1234567Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put("韦德", "35");Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + ":" + entry.getValue());&#125; map的遍历方式可参考 java中遍历Map的几种方法 collection 迭代collection接口继承了Iterable接口，因此只要是collection实例，都可以使用迭代器进行遍历 123456Collection&lt;String&gt; collection = Arrays.asList("java", "c", "js");Iterator&lt;String&gt; iterator = collection.iterator();while (iterator.hasNext()) &#123; String str = iterator.next(); System.out.println(str);&#125; 用迭代器遍历collection的优势在于遍历的过程中可以remove元素，用foreach则不行 ListIteratorListIterator是对Iterator的扩展，针对定义了ListIterator方法的有序的容器，可以采用ListIterator进行迭代，ListIterator新增了一些方法，可以在遍历时获取数据的索引，或者逆序遍历等。 123456789101112131415161718192021222324public interface ListIterator1&lt;E&gt; extends Iterator&lt;E&gt; &#123; // 是否还有上一个元素 一般逆序遍历时使用 boolean hasPrevious(); // 返回列表中的上一个元素 E previous(); // 返回对 next 的后续调用所返回元素的索引。（如果列表迭代器在列表的结尾，则返回列表的大小） int nextIndex(); // 返回对 previous 的后续调用所返回元素的索引。（如果列表迭代器在列表的开始，则返回 -1） int previousIndex(); // 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。只有在最后一次调用 next 或 previous // 后既没有调用 ListIterator.remove 也没有调用 ListIterator.add 时才可以进行该调用。 void set(E e); // 将指定的元素插入列表（可选操作）。该元素直接插入到 next 返回的下一个元素的前面（如果有） //或者 previous 返回的下一个元素之后（如果有）； void add(E e); // ... Iterator methods&#125; List提供了两个重载的listIterator方法，可以通过这两个方法拿到一个ListIterator对象 123456789101112public interface List1&lt;E&gt; extends Collection&lt;E&gt; &#123; // 此列表元素的列表迭代器 ListIterator&lt;E&gt; listIterator(); // 此列表元素的列表迭代器 可以指定一个参数index // index 从列表迭代器返回的第一个元素的索引（通过调用 next 方法） ListIterator&lt;E&gt; listIterator(int index); // List other methods&#125; 使用listIterator对List进行逆序遍历 123456List&lt;String&gt; list = Arrays.asList("java", "c", "js");ListIterator&lt;String&gt; listIterator = list.listIterator(list.size());while (listIterator.hasPrevious()) &#123; System.out.println("前一个元素索引为：" + listIterator.previousIndex()); System.out.println("前一个元素为：" + listIterator.previous());&#125; 光标（cursor）迭代器没有当前元素的概念，但有光标（cursor）的概念，如果不指定光标的位置，光标默认在第一个元素之前，此时如果调用next方法，光标会跳到第一个元素和第二个元素中间，并且返回第一个元素 1ListIterator&lt;String&gt; listIterator = list.listIterator(list.size()); 以上代码，指定了光标的位置，在最后一个元素的后面，此次要调用next方法会抛异常，因为没有下一个元素，如果调用nextIndex则会返回容器长度，调用previous则返回最后一个元素，同时光标向上移动一位 总结迭代器在使用的过程中其实还有诸多限制，如果使用不当，很可能出现死循环，抛异常等问题，例如:如果在用ListIterator逆序遍历的时候新增，会造成死循环。 因此在学习迭代器的时候，不仅要掌握其使用方法，还要明白其实现原理。看源码是不错的学习办法，有兴趣的可以看看Collection的众多实现类对迭代的实现。]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈java中遍历Map的几种方法]]></title>
    <url>%2F2017%2F06%2F24%2F%E8%B0%88%E8%B0%88java%E4%B8%AD%E9%81%8D%E5%8E%86Map%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java中的map遍历有多种方法，从最早的Iterator，到java5支持的foreach,再到java8 Lambda，让我们一起来看下具体的用法以及各自的优缺点 先初始化一个map 123public class TestMap &#123; public static Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();&#125; keySet values如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的 123456789101112// KeySet 获取keypublic void testKeySet() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key); &#125;&#125;// values 获取valuepublic void testValues() &#123; for (Integer value : map.values()) &#123; System.out.println(value); &#125;&#125; keySet get(key)如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value 需要说明的是，该方法不是最优选择，一般不推荐使用 123456// keySet get(key) 获取key and valuepublic void testKeySetAndGetKey() &#123; for (Integer key : map.keySet()) &#123; System.out.println(key + ":" + map.get(key)); &#125;&#125; entrySet通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于上一种,这一种也是最常用的遍历方法 123456// entrySet 获取key and valuepublic void testEntry() &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ":" + entry.getValue()); &#125;&#125; Iterator对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁 但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素 123456789// Iterator entrySet 获取key and valuepublic void testIterator() &#123; Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println(entry.getKey() + ":" + entry.getValue()); // it.remove(); 删除元素 &#125;&#125; Lambdajava8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 123456// Lambda 获取key and valuepublic void testLambda() &#123; map.forEach((key, value) -&gt; &#123; System.out.println(key + ":" + value); &#125;);&#125; 简单性能测试用10万条数据，做了一个简单性能测试，数据类型为Integer，map实现选取HashMap 12345static &#123; for (int i = 0; i &lt; 100000; i++) &#123; map.put(i, 1); &#125;&#125; 测试结果如下： 123456KeySet： 392Values： 320keySet get(key)： 552entrySet： 465entrySet Iterator：508Lambda： 536 需要说明的是，map存储的数据类型，map的大小，以及map的不同实现方式都会影响遍历的性能，所以该测试结果仅供参考 总结如果只是获取key，或者value，推荐使用keySet或者values方式 如果同时需要key和value推荐使用entrySet 如果需要在遍历过程中删除元素推荐使用Iterator 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2017%2F05%2F28%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[##目录 什么是反射 初探 初始化 类 构造函数 属性 方法 总结 思考 ##什么是反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 ##初探对反射的最初接触是学习jdbc时，加载数据库驱动时会这样写：Class.forName(“com.mysql.jdbc.Driver”),当时似懂非懂的也不知道是什么意思，随着自己的不断学习，越来越感觉反射的神奇，让我们一起来揭开它的神秘面纱吧。 学习一个知识，自然是最先从api开始，反射涉及的类，除了Class类之外，基本上都在java.lang.reflect包里面，常用的类有Constructor，Field，Method类等，AccessibleObject类是前面三个类的基类，主要包含设置安全性检查等方法，下面，我们看一下reflect包的结构 可以看出，涉及的类并不多，让我一起来看一下其中比较常用的类的用法吧 ##初始化测试用例采用junit+log4j,新建一个test类，一个javabean 其中name属性get,set方法用private修饰 User类 12345678910111213141516171819202122232425262728package com.test;public class User &#123; private String name = "init"; private int age; public User() &#123;&#125; public User(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; private String getName() &#123; return name; &#125; private void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "User [name=" + name + ", age=" + age + "]"; &#125;&#125; Test类 1234public class ReflectTest &#123; private static Logger logger = Logger.getLogger(ReflectTest.class); private static Class&lt;User&gt; userClass = User.class;&#125; ##类在类加载的时候，jvm会创建一个class对象 class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种 根据类名：类名.class 根据对象：对象.getClass() 根据全限定类名：Class.forName(全限定类名) 1234567891011@Testpublic void classTest() throws Exception &#123; // 获取Class对象的三种方式 logger.info("根据类名: \t" + User.class); logger.info("根据对象: \t" + new User().getClass()); logger.info("根据全限定类名:\t" + Class.forName("com.test.User")); // 常用的方法 logger.info("获取全限定类名:\t" + userClass.getName()); logger.info("获取类名:\t" + userClass.getSimpleName()); logger.info("实例化:\t" + userClass.newInstance());&#125; console 123456根据类名: class com.test.User根据对象: class com.test.User根据全限定类名: class com.test.User获取全限定类名: com.test.User获取类名: com.test.User实例化: User [name=init, age=0] ##构造函数构造函数是java创建对象的必经之路，所以通过反射拿到一个类的构造函数后，再去创建这个类的对象自然是易如反掌，常用的方法如下： 123456789101112131415161718@Testpublic void constructorTest() throws Exception &#123; // 获取全部的构造函数 Constructor&lt;?&gt;[] constructors = userClass.getConstructors(); // 取消安全性检查,设置后才可以使用private修饰的构造函数，也可以单独对某个构造函数进行设置 // Constructor.setAccessible(constructors, true); for (int i = 0; i &lt; constructors.length; i++) &#123; Class&lt;?&gt; parameterTypesClass[] = constructors[i].getParameterTypes(); System.out.print("第" + i + "个构造函数:\t ("); for (int j = 0; j &lt; parameterTypesClass.length; j++) &#123; System.out.print(parameterTypesClass[j].getName() + (j == parameterTypesClass.length - 1 ? "" : "\t")); &#125; logger.info(")"); &#125; // 调用构造函数，实例化对象 logger.info("实例化，调用无参构造:\t" + constructors[0].newInstance()); logger.info("实例化，调用有参构造:\t" + constructors[1].newInstance("韦德", 35));&#125; console 1234第0个构造函数: ()第1个构造函数: (java.lang.String int)实例化，调用无参构造: User [name=init, age=0]实例化，调用有参构造: User [name=韦德, age=35] ##属性犹记得学习spring ioc之时，对未提供set方法的private属性依然可以注入感到神奇万分，现在看来，这神奇的根源自然是来自于java的反射，常用的方法如下： 1234567891011121314151617181920@Testpublic void fieldTest() throws Exception &#123; User user = userClass.newInstance(); // 获取当前类所有属性 Field fields[] = userClass.getDeclaredFields(); // 获取公有属性(包括父类) // Field fields[] = cl.getFields(); // 取消安全性检查,设置后才可以获取或者修改private修饰的属性，也可以单独对某个属性进行设置 Field.setAccessible(fields, true); for (Field field : fields) &#123; // 获取属性名 属性值 属性类型 logger.info("属性名:" + field.getName() + "\t属性值:" + field.get(user) + " \t属性类型:" + field.getType()); &#125; Field fieldUserName = userClass.getDeclaredField("name"); // 取消安全性检查,设置后才可以获取或者修改private修饰的属性，也可以批量对所有属性进行设置 fieldUserName.setAccessible(true); fieldUserName.set(user, "韦德"); // 可以直接对 private 的属性赋值 logger.info("修改属性后对象:\t" + user);&#125; console 123属性名:name 属性值:init 属性类型:class java.lang.String属性名:age 属性值:0 属性类型:int修改属性后对象: User [name=韦德, age=0] ##方法大家对javabean肯定不会陌生，在用框架操作javabean时，大多都是通过反射调用get,set方法Javabean进行操作，常用的方法如下： 123456789101112131415161718192021222324252627@Testpublic void methodTest() throws Exception &#123; User user = userClass.newInstance(); // 获取当前类的所有方法 Method[] methods = userClass.getDeclaredMethods(); // 获取公有方法(包括父类) // Method[] methods = userClass.getMethods(); // 取消安全性检查,设置后才可以调用private修饰的方法，也可以单独对某个方法进行设置 Method.setAccessible(methods, true); for (Method method : methods) &#123; // 获取方法名和返回类型 获取参数类型：getParameterTypes logger.info("方法名:" + method.getName() + " \t返回类型:" + method.getReturnType().getName()); &#125; // 获取无参方法 Method getMethod = userClass.getDeclaredMethod("getName"); // 取消安全性检查,设置后才可以调用private修饰的方法，也可以批量对所有方法进行设置 getMethod.setAccessible(true); // 调用无参方法 logger.info("调用getName方法：" + getMethod.invoke(user)); // 获取有参方法 Method setMethod = userClass.getDeclaredMethod("setName", String.class); // 取消安全性检查,设置后才可以调用private修饰的方法，也可以批量对所有方法进行设置 setMethod.setAccessible(true); // 调用有参方法 logger.info("调用setName方法：" + setMethod.invoke(user, "韦德")); logger.info("通过set方法修改属性后对象:\t" + user);&#125; console 12345678方法名:toString 返回类型:java.lang.String方法名:setAge 返回类型:void方法名:getAge 返回类型:int方法名:getName 返回类型:java.lang.String方法名:setName 返回类型:void调用getName方法：init调用setName方法：null通过set方法修改属性后对象: User [name=韦德, age=0] 完整的 源码 https://github.com/zhaoguhong/blogsrc ##总结不难看出，Java反射中的构造函数，属性，方法有着诸多相似之处，不仅仅是因为它们有着共同的父类AccessibleObject，基本上所有的api都有相似之处。学习的过程中死记api是最愚蠢的，找方法，理解反射的设计思路。去尝试感悟设计思想，才是王道。 上面只是对反射的常用方法提供了示例，最好的学习方法自然是参照api,自己去实践。纸上得来终觉浅，绝知此事要躬行。通过自己的不断练习，体会，思考，达到融会贯通的目的。 ##思考java以面向对象和封装性著称,但反射在java中堪称作弊器，似乎无所不能，给人一种建了一道围墙，下面又留了一道门的感觉，是否破坏了程序的封装性？ 笔者认为：循规蹈矩固然好，但过于注重规范反而影响程序的灵活性。Java反射给我们带了灵活性的同时，极大的方便了我们的编程，而且反射堪称各大框架的基础。如此看来，显然利大于弊，你怎么看？]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMvc注解之@ResponseBody和@RequestBody]]></title>
    <url>%2F2017%2F05%2F21%2FspringMvc%E6%B3%A8%E8%A7%A3%E4%B9%8B%40ResponseBody%E5%92%8C%40RequestBody%2F</url>
    <content type="text"><![CDATA[##简介springmvc对json的前后台传输做了很好封装，避免了重复编码的过程，下面来看看常用的@ResponseBody和@RequestBody注解 ##添加依赖springmvc对json的处理依赖jackson 12345678910&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.11&lt;/version&gt;&lt;/dependency&gt; ##xml配置 1&lt;mvc:annotation-driven /&gt;//不要忘了命名空间配置 ###@ResponseBody如果传输的是单层json对象，我们后台可以直接用 @RequestParam接收 1234567891011$.ajax(&#123; type : "post", dataType : "json", url : "/testRequestBody", data:&#123; name:"韦德", age:35 &#125;, success : function(result) &#123; &#125;&#125;); 12345@RequestMapping("/testRequestBody")public String testRequestBody(@RequestParam Map&lt;String, Object&gt; map) &#123; System.out.println(map);// &#123;name=韦德, age=35&#125; return "index";&#125; 如果传输的是多层嵌套json对象，这个时候会就会出现数据丢失问题 注解@RequestMapping很好的解决了这个问题，它会把前台传输过来的json转化为后台对应的对象 12345678910111213$.ajax(&#123; type : "post", dataType : "json", url : "/testRequestBody", contentType:"application/json", data:JSON.stringify(&#123; name:"韦德", win:[2006,2012,2013], age:35 &#125;), success : function(result) &#123; &#125;&#125;); 12345@RequestMapping("/testRequestBody")public String testRequestBody(@RequestBody Map&lt;String, Object&gt; map) &#123; System.out.println(map);//&#123;name=韦德, win=[2006, 2012, 2013], age=35&#125; return "index";&#125; 需要注意的是前台需要指定contentType为”application/json” 同时要把json对象转化为String，否则后台不能识别 ##@ResponseBodyajax请求返回json格式，往常我们可以这样做 12345678910111213141516private void writeJson(HttpServletResponse response, Object object) &#123; String json = JSON.toJSONString(object); response.setCharacterEncoding("UTF-8"); response.setContentType("application/json; charset=utf-8"); PrintWriter out = null; try &#123; out = response.getWriter(); out.write(json); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) &#123; out.close(); &#125; &#125;&#125; 这个时候 @ResponseBody就派上用场了，只需要一个注解，全部搞定 12345678$.ajax(&#123; type : "post", dataType : "json", url : "/testResponseBody", success : function(result) &#123; console.info(result); &#125;&#125;); 12345678@RequestMapping("/testResponseBody")@ResponseBodypublic Map&lt;String, Object&gt; testRequestBody() &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put("name", "韦德"); result.put("age", 35); return result;&#125; 前台console输出 1234&#123; "age": 35, "name": "韦德"&#125; ##总结在网上看到很不错的流程图，作为总结吧]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
